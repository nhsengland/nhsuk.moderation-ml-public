import hashlib
import os
import subprocess

from azureml.core import Environment, Workspace
from azureml.core.conda_dependencies import CondaDependencies

from src.azure_config import azure_config


def get_environment_object(env_name: str, env_version):
    return Environment.get(
        workspace=azure_config.get_workspace(), name=env_name, version=str(env_version)
    )


def find_project_root(start_dir: str = None) -> str:
    """
    DEPRECATED: Probably if you're calling this there's a mistake. But! Keeping this here because plausible we'll need it.
    For pipreqs to work, it needs to look at all the packages which will be imported. In order to do that, it needs to look through all the modules and check their imports. In order to do *that*, it needs to know where the project root it. So this looks into parent folders until it finds a README.
    WAYS THIS CAN GO WRONG:
    Because of the kind of weird structure of Azure MLS, we could end up with a situation where this function looks up until it reaches, say the Users folder. This shouldn't happen, but I'm just flagging it. If you get a crazy long requirements list, that's probably what's happened.
    """

    print(
        "You've called 'find_project_root'. To avoid chaos, make sure that the script or notebook you're running is itself in the project root. "
    )
    print("This is deprecated because we use conda now. Don't use this")
    start_dir = start_dir or os.getcwd()
    current_dir = start_dir
    while True:
        if "README.md" in os.listdir(current_dir):
            return current_dir
        parent_dir = os.path.dirname(current_dir)
        if parent_dir == current_dir:
            raise FileNotFoundError(
                f"No README.md found between {start_dir} and the filesystem root"
            )
        current_dir = parent_dir


def export_conda_environment(filepath="environment.yml"):
    try:
        with open(filepath, "w") as file:
            subprocess.run(["conda", "env", "export"], stdout=file, check=True)
        print(f"Environment exported to {filepath}")
    except subprocess.CalledProcessError as e:
        print(f"An error occurred: {e}")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")


def capture_requirements(conda_env_file="environment.yml", lock_file="conda.lock"):
    # Generate a lock file using conda-lock
    cmd = f"conda-lock -f {conda_env_file} -p linux-64"  # Change platform if necessary
    process = subprocess.run(
        cmd, shell=True, check=True, text=True, capture_output=True
    )
    if process.returncode == 0:
        print(f"Lock file generated: {lock_file}")
    else:
        print("Error:", process.stderr)


def register_environment(lock_file="conda.lock", env_name_prefix="env") -> str:
    """
    Registers an Azure ML environment using a lock file generated by conda-lock.

    This function reads a lock file to get the list of required packages,
    generates a unique name for the environment based on the contents of the
    lock file, and registers the environment with the Azure ML workspace. If an
    environment with the generated name already exists, it returns the existing
    environment. Otherwise, it creates and registers a new environment.

    Parameters:
    workspace (Workspace): The Azure ML workspace object.
    lock_file (str, optional): The path to the lock file generated by conda-lock.
    env_name_prefix (str, optional): The prefix for the environment name.

    Returns:
    str: The name of the registered environment.

    Example:
    >>> workspace = Workspace.from_config()
    >>> register_environment(workspace, lock_file='conda.lock')
    'env-abcdef1234567890'
    """
    workspace = azure_config.get_workspace()
    with open(lock_file, "r") as file:
        lock_contents = file.read()
    hash_object = hashlib.md5(lock_contents.encode())
    env_name = f"{env_name_prefix}-{hash_object.hexdigest()}"

    if env_name in workspace.environments:
        print(f"Environment {env_name} already exists")
        return workspace.environments[env_name]
    else:
        env = Environment(name=env_name)
        env.python.conda_dependencies.set_dependencies_lock_file(lock_contents)
        env.register(workspace)
        print(f"Environment {env_name} registered")
        return env_name


def register_environment(filepath="environment.yml") -> str:
    """
    NOTE: Not really using this function. Could come in handy though, so keeping it in.
    Registers an Azure ML environment using a Conda specification file.

    This function reads a Conda specification file to get the list of
    required packages, generates a unique name for the environment based
    on the contents of the specification file, and registers the environment
    with the Azure ML workspace. If an environment with the generated name
    already exists, it returns the existing environment. Otherwise, it creates
    and registers a new environment.

    Parameters:
    filepath (str, optional): The path to the Conda specification file.

    Returns:
    str: The name of the registered environment.

    Example:
    >>> register_environment(filepath='environment.yml')
    'env-abcdef1234567890'
    """
    print("Are you sure you want to do this rather than call down a registered env?")
    requirements = read_requirements_file(filepath=filepath)
    workspace = azure_config.get_workspace()
    requirements_str = "\n".join(requirements)
    hash_object = hashlib.md5(requirements_str.encode())
    env_name = f"env-{hash_object.hexdigest()}"

    if env_name in workspace.environments:
        print(f"Environment {env_name} already exists")
        return workspace.environments[env_name]
    else:
        env = Environment.from_conda_specification(name=env_name, file_path=filepath)
        env.register(workspace)
        print(f"Environment {env_name} registered")
    return env_name


def make_and_register_environment():
    export_conda_environment()
    register_environment()


def _load_specific_environment(
    env_name: str, version: int = 1, create_conda_env: bool = True
):
    """ """
    workspace = azure_config.get_workspace()
    env = Environment.get(workspace, name=env_name, version=version)

    env.save_to_directory(path=f"./{env_name}", overwrite=True)

    if create_conda_env:
        subprocess.run(
            [
                "conda",
                "env",
                "create",
                f"--file",
                f"./{env_name}/conda_dependencies.yml",
                f"--name",
                env_name,
            ],
            check=True,
        )
        print(f"Conda environment {env_name} created")
    else:
        subprocess.run(
            [
                "pip",
                "install",
                f"--requirement",
                f"./{env_name}/conda_dependencies.yml",
            ],
            check=True,
        )
        print(f"Dependencies installed in current environment")


def load_correct_environment():
    """
    This loads the environment which is stated in the azure_config file.
    """
    _load_specific_environment(
        env_name=azure_config.ENVIRONMENT_NAME,
        version=azure_config.ENVIRONMENT_VERSION,
        create_conda_env=True,
    )
    print("Don't forget to activate this new environment!")


def check_environment_is_correct():
    assert (
        get_current_conda_env() == azure_config.ENVIRONMENT_NAME
    ), "Your environment doesn't match the one in the azure config. "


def get_current_conda_env():
    return os.environ.get("CONDA_DEFAULT_ENV")


def remove_conda_environment(env_name: str):
    """
    Remove a conda environment with the given name.

    Parameters:
    env_name (str): The name of the conda environment to remove.
    """
    try:
        subprocess.run(["conda", "env", "remove", "--name", env_name], check=True)
        print(f"Environment '{env_name}' has been removed.")
    except subprocess.CalledProcessError as e:
        print(f"An error occurred while trying to remove environment '{env_name}': {e}")


def refresh_the_correct_conda_environment():
    remove_conda_environment(azure_config.ENVIRONMENT_NAME)
    load_correct_environment()
